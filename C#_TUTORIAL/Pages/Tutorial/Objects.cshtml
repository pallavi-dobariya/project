@page
@model Objects
@{
    ViewData["Title"] = "Objects";
}
<html>
    <head>
        <title>c# tutorial</title>
        <link rel="stylesheet" href="~/css/Style.css" />
        <script>
            const Serach_Menu = () =>{
                let filter = document.getElementById('Search').value.toUpperCase();
                let ul = document.getElementById('Search_ul');
                let li = ul.getElementsByTagName('li');
                for(var i=0;i<li.length;i++)
                {
                    let a = li[i].getElementsByTagName('a')[0];
                    let txtvalue = a.textContent || a.innerHTML;
                    if(txtvalue.toUpperCase().indexOf(filter) > -1)
                    {
                        li[i].style.display = '';
                    }
                    else
                    {
                        li[i].style.display = 'none';
                    }
                }
            }
        </script>
    </head>
    <body>
        <div class="Sidebar">
            <div class="Search">
            <input type="text" class="SearchBar"placeholder="Type Here For Search" id="Search" onkeyup="Serach_Menu()">
            </div>
            <div class="side_Scroll">
            <ul id="Search_ul">
                <li><a  href="~/Tutorial/Introduction"><i></i>Introduction</a></li>
                <li><a  href="~/Tutorial/Top_Level_Stat"><i></i>Top&nbsp;Level&nbsp;Statement</a></li>
                <li><a  href="~/Tutorial/Namespaces"><i></i>Namespaces</a></li>
                <li><a  href="~/Tutorial/Classes"><i></i>Classes</a></li>
                <li><a  href="~/Tutorial/Records"><i></i>Records</a></li>
                <li><a  href="~/Tutorial/Interfaces"><i></i>Interfaces</a></li>
                <li><a  href="~/Tutorial/Generic"><i></i>Generic</a></li>
                <li><a  href="~/Tutorial/Anonymous"><i></i>Anonymous</a></li>
                <li><a  href="~/Tutorial/Class_Struct_Record"><i></i>Classes&nbsp;Structs&nbsp;Records</a></li>
                <li><a  href="~/Tutorial/Objects"><i></i>Objects</a></li>
                <li><a  href="~/Tutorial/Inheritance"><i></i>Inheritance</a></li>
                <li><a  href="~/Tutorial/Polymorphism"><i></i>Polymorphism</a></li>
                <li><a  href="~/Tutorial/Pattern_Matching"><i></i>Pattern Matching</a></li>
                <li><a  href="~/Tutorial/Discards"><i></i>Discards</a></li>
                <li><a  href="~/Tutorial/Exception_Over"><i></i>Exception Overview</a></li>
                <li><a  href="~/Tutorial/Exception_Use"><i></i>Use Exception</a></li>
                  <li><a  href="~/Tutorial/Exception_Create_Throw">Creating&nbsp;&&nbsp;Throwing&nbsp;Exception</a></li>
                <li><a  href="~/Tutorial/Exception_Compiler">Compiler&nbsp;generated&nbsp;Exceptions</a></li><br>
            </ul>
            </div>
        </div>

        <div class="Content">
        <p class="padding">
        <h2>
               Objects - create instances of types
        </h2>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A class or struct definition is like a blueprint that specifies what the type can do. An object is basically a block of memory that has been allocated and configured according to the blueprint. A program may create many objects of the same class. Objects are also called instances, and they can be stored in either a named variable or in an array or collection. Client code is the code that uses these variables to call the methods and access the public properties of the object. In an object-oriented language such as C#, a typical program consists of multiple objects interacting dynamically.<br><br>
        <h2>
            Struct Instances vs. Class Instances
        </h2>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Because classes are reference types, a variable of a class object holds a reference to the address of the object on the managed heap. If a second variable of the same type is assigned to the first variable, then both variables refer to the object at that address. This point is discussed in more detail later in this article.<br><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instances of classes are created by using the new operator. In the following example, Person is the type and person1 and person2 are instances, or objects, of that type.<br><br>
        <h2>
            Example
        </h2>
        <iframe width="100%" height="475" src="https://dotnetfiddle.net/Widget/1vU3TZ" frameborder="0"></iframe><br><br>
        <h2>
            Object Identity vs. Value Equality
        </h2>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When you compare two objects for equality, you must first distinguish whether you want to know whether the two variables represent the same object in memory, or whether the values of one or more of their fields are equivalent. If you're intending to compare values, you must consider whether the objects are instances of value types (structs) or reference types (classes, delegates, arrays).<br><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- To determine whether two class instances refer to the same location in memory (which means that they have the same identity), use the static Object.Equals method. (System.Object is the implicit base class for all value types and reference types, including user-defined structs and classes.)<br><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- To determine whether the instance fields in two struct instances have the same values, use the ValueType.Equals method. <br><br>
        <h2>
            Example
        </h2>
        <iframe width="100%" height="475" src="https://dotnetfiddle.net/Widget/tczaho" frameborder="0"></iframe>
        </p>
</div>
    </body>
</html>
@page
@model Generic
@{
    ViewData["Title"] = "Generic";
}
<html>
    <head>
        <title>c# tutorial</title>
        <link rel="stylesheet" href="~/css/Style.css" />
        <script>
            const Serach_Menu = () =>{
                let filter = document.getElementById('Search').value.toUpperCase();
                let ul = document.getElementById('Search_ul');
                let li = ul.getElementsByTagName('li');
                for(var i=0;i<li.length;i++)
                {
                    let a = li[i].getElementsByTagName('a')[0];
                    let txtvalue = a.textContent || a.innerHTML;
                    if(txtvalue.toUpperCase().indexOf(filter) > -1)
                    {
                        li[i].style.display = '';
                    }
                    else
                    {
                        li[i].style.display = 'none';
                    }
                }
            }
        </script>
    </head>
    <body>
        <div class="Sidebar">
            <div class="Search">
            <input type="text" class="SearchBar"placeholder="Type Here For Search" id="Search" onkeyup="Serach_Menu()">
            </div>
            <div class="side_Scroll">
            <ul id="Search_ul">
                <li><a  href="~/Tutorial/Introduction"><i></i>Introduction</a></li>
                <li><a  href="~/Tutorial/Top_Level_Stat"><i></i>Top&nbsp;Level&nbsp;Statement</a></li>
                <li><a  href="~/Tutorial/Namespaces"><i></i>Namespaces</a></li>
                <li><a  href="~/Tutorial/Classes"><i></i>Classes</a></li>
                <li><a  href="~/Tutorial/Records"><i></i>Records</a></li>
                <li><a  href="~/Tutorial/Interfaces"><i></i>Interfaces</a></li>
                <li><a  href="~/Tutorial/Generic"><i></i>Generic</a></li>
                <li><a  href="~/Tutorial/Anonymous"><i></i>Anonymous</a></li>
                <li><a  href="~/Tutorial/Class_Struct_Record"><i></i>Classes&nbsp;Structs&nbsp;Records</a></li>
                <li><a  href="~/Tutorial/Objects"><i></i>Objects</a></li>
                <li><a  href="~/Tutorial/Inheritance"><i></i>Inheritance</a></li>
                <li><a  href="~/Tutorial/Polymorphism"><i></i>Polymorphism</a></li>
                <li><a  href="~/Tutorial/Pattern_Matching"><i></i>Pattern Matching</a></li>
                <li><a  href="~/Tutorial/Discards"><i></i>Discards</a></li>
                <li><a  href="~/Tutorial/Exception_Over"><i></i>Exception Overview</a></li>
                <li><a  href="~/Tutorial/Exception_Use"><i></i>Use Exception</a></li>
                 <li><a  href="~/Tutorial/Exception_Create_Throw">Creating&nbsp;&&nbsp;Throwing&nbsp;Exception</a></li>
                <li><a  href="~/Tutorial/Exception_Compiler">Compiler&nbsp;generated&nbsp;Exceptions</a></li><br>
            </ul>
            </div>
        </div>
        <div class="Content">
       <p class="padding">
        <h2>
               Generic classes and methods
        </h2>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generics introduces the concept of type parameters to .NET, which make it possible to design classes and methods that defer the specification of one or more types until the class or method is declared and instantiated by client code. For example, by using a generic type parameter T, you can write a single class that other client code can use without incurring the cost or risk of runtime casts or boxing operations, as shown here:<br><br>
        <h2>
            Example
        </h2>
        <iframe width="100%" height="475" src="https://dotnetfiddle.net/Widget/OYsM97" frameborder="0"></iframe><br><br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Generic classes and methods combine reusability, type safety, and efficiency in a way that their non-generic counterparts cannot. Generics are most frequently used with collections and the methods that operate on them. The System.Collections.Generic namespace contains several generic-based collection classes. The non-generic collections, such as ArrayList are not recommended and are maintained for compatibility purposes. For more information, see Generics in .NET.<br><br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You can also create custom generic types and methods to provide your own generalized solutions and design patterns that are type-safe and efficient. The following code example shows a simple generic linked-list class for demonstration purposes. (In most cases, you should use the List<T> class provided by .NET instead of creating your own.) The type parameter T is used in several locations where a concrete type would ordinarily be used to indicate the type of the item stored in the list. It is used in the following ways:<br><br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - As the type of a method parameter in the AddHead method.<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  - As the return type of the Data property in the nested Node class.<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - As the type of the private member data in the nested class.<br>

        </p>
</div>
    </body>
</html>
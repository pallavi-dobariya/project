@page
@model Records
@{
    ViewData["Title"] = "Records";
}
<html>
    <head>
        <title>c# tutorial</title>
        <link rel="stylesheet" href="~/css/Style.css" />
        <script>
            const Serach_Menu = () =>{
                let filter = document.getElementById('Search').value.toUpperCase();
                let ul = document.getElementById('Search_ul');
                let li = ul.getElementsByTagName('li');
                for(var i=0;i<li.length;i++)
                {
                    let a = li[i].getElementsByTagName('a')[0];
                    let txtvalue = a.textContent || a.innerHTML;
                    if(txtvalue.toUpperCase().indexOf(filter) > -1)
                    {
                        li[i].style.display = '';
                    }
                    else
                    {
                        li[i].style.display = 'none';
                    }
                }
            }
        </script>
    </head>
    <body>
        <div class="Sidebar">
            <div class="Search">
            <input type="text" class="SearchBar"placeholder="Type Here For Search" id="Search" onkeyup="Serach_Menu()">
            </div>
            <div class="side_Scroll">
            <ul id="Search_ul">
                <li><a  href="~/Tutorial/Introduction"><i></i>Introduction</a></li>
                <li><a  href="~/Tutorial/Top_Level_Stat"><i></i>Top&nbsp;Level&nbsp;Statement</a></li>
                <li><a  href="~/Tutorial/Namespaces"><i></i>Namespaces</a></li>
                <li><a  href="~/Tutorial/Classes"><i></i>Classes</a></li>
                <li><a  href="~/Tutorial/Records"><i></i>Records</a></li>
                <li><a  href="~/Tutorial/Interfaces"><i></i>Interfaces</a></li>
                <li><a  href="~/Tutorial/Generic"><i></i>Generic</a></li>
                <li><a  href="~/Tutorial/Anonymous"><i></i>Anonymous</a></li>
                <li><a  href="~/Tutorial/Class_Struct_Record"><i></i>Classes&nbsp;Structs&nbsp;Records</a></li>
                <li><a  href="~/Tutorial/Objects"><i></i>Objects</a></li>
                <li><a  href="~/Tutorial/Inheritance"><i></i>Inheritance</a></li>
                <li><a  href="~/Tutorial/Polymorphism"><i></i>Polymorphism</a></li>
                <li><a  href="~/Tutorial/Pattern_Matching"><i></i>Pattern Matching</a></li>
                <li><a  href="~/Tutorial/Discards"><i></i>Discards</a></li>
                <li><a  href="~/Tutorial/Exception_Over"><i></i>Exception Overview</a></li>
                <li><a  href="~/Tutorial/Exception_Use"><i></i>Use Exception</a></li>
                 <li><a  href="~/Tutorial/Exception_Create_Throw">Creating&nbsp;&&nbsp;Throwing&nbsp;Exception</a></li>
                <li><a  href="~/Tutorial/Exception_Compiler">Compiler&nbsp;generated&nbsp;Exceptions</a></li><br>
            </ul>
            </div>
        </div>
        <div class="Content">
        <p class="padding">
        <h2>
            Introduction to record types in C#     
        </h2>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A record in C# is a class or struct that provides special syntax and behavior for working with data models.<br><br>
        <h2>
            When to use records
        </h2>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Consider using a record in place of a class or struct in the following scenarios:<br><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- You want to define a data model that depends on value equality.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- You want to define a type for which objects are immutable.<br><br>
        <h2>
            Value equality
        </h2>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For records, value equality means that two variables of a record type are equal if the types match and all property and field values match. For other reference types such as classes, equality means reference equality. That is, two variables of a class type are equal if they refer to the same object. Methods and operators that determine equality of two record instances use value equality.<br><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Not all data models work well with value equality. For example, Entity Framework Core depends on reference equality to ensure that it uses only one instance of an entity type for what is conceptually one entity. For this reason, record types aren't appropriate for use as entity types in Entity Framework Core.<br><br>
        <h2>
            Immutability
        </h2>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An immutable type is one that prevents you from changing any property or field values of an object after it's instantiated. Immutability can be useful when you need a type to be thread-safe or you're depending on a hash code remaining the same in a hash table. Records provide concise syntax for creating and working with immutable types.<br><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Immutability isn't appropriate for all data scenarios. Entity Framework Core, for example, doesn't support updating with immutable entity types.<br><br>
        <h2>
            Examples
        </h2>
        <iframe width="100%" height="475" src="https://dotnetfiddle.net/Widget/mc2mZp" frameborder="0"></iframe>
        </p>
</div>
    </body>
</html>
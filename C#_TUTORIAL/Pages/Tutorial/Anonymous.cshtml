@page
@model Anonymous
@{
    ViewData["Title"] = "Anonymous";
}
<html>
    <head>
        <title>c# tutorial</title>
        <link rel="stylesheet" href="~/css/Style.css" />
        <script>
            const Serach_Menu = () =>{
                let filter = document.getElementById('Search').value.toUpperCase();
                let ul = document.getElementById('Search_ul');
                let li = ul.getElementsByTagName('li');
                for(var i=0;i<li.length;i++)
                {
                    let a = li[i].getElementsByTagName('a')[0];
                    let txtvalue = a.textContent || a.innerHTML;
                    if(txtvalue.toUpperCase().indexOf(filter) > -1)
                    {
                        li[i].style.display = '';
                    }
                    else
                    {
                        li[i].style.display = 'none';
                    }
                }
            }
        </script>
    </head>
    <body>
        <div class="Sidebar">
            <div class="Search">
            <input type="text" class="SearchBar"placeholder="Type Here For Search" id="Search" onkeyup="Serach_Menu()">
            </div>
            <div class="side_Scroll">
            <ul id="Search_ul">
                <li><a  href="~/Tutorial/Introduction"><i></i>Introduction</a></li>
                <li><a  href="~/Tutorial/Top_Level_Stat"><i></i>Top&nbsp;Level&nbsp;Statement</a></li>
                <li><a  href="~/Tutorial/Namespaces">Namespaces</a></li>
                <li><a  href="~/Tutorial/Classes">Classes</a></li>
                <li><a  href="~/Tutorial/Records"><i>Records</a></li>
                <li><a  href="~/Tutorial/Interfaces">Interfaces</a></li>
                <li><a  href="~/Tutorial/Generic">Generic</a></li>
                <li><a  href="~/Tutorial/Anonymous">Anonymous</a></li>
                <li><a  href="~/Tutorial/Class_Struct_Record">Classes&nbsp;Structs&nbsp;Records</a></li>
                <li><a  href="~/Tutorial/Objects">Objects</a></li>
                <li><a  href="~/Tutorial/Inheritance">Inheritance</a></li>
                <li><a  href="~/Tutorial/Polymorphism">Polymorphism</a></li>
                <li><a  href="~/Tutorial/Pattern_Matching">Pattern Matching</a></li>
                <li><a  href="~/Tutorial/Discards">Discards</a></li>
                <li><a  href="~/Tutorial/Exception_Over">Exception Overview</a></li>
                <li><a  href="~/Tutorial/Exception_Use">Use Exception</a></li>
                  <li><a  href="~/Tutorial/Exception_Create_Throw">Creating&nbsp;&&nbsp;Throwing&nbsp;Exception</a></li>
                <li><a  href="~/Tutorial/Exception_Compiler">Compiler&nbsp;generated&nbsp;Exceptions</a></li><br>

            </ul>
            </div>
        </div>
        <div class="Content">
        <p class="padding">
        <h2>
               Anonymous Types
        </h2>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first. The type name is generated by the compiler and is not available at the source code level. The type of each property is inferred by the compiler.<br><br>
        You create anonymous types by using the new operator together with an object initializer. For more information about object initializers, see Object and Collection Initializers.<br><br>
        <h2>
            Example
        </h2>
        <iframe width="100%" height="475" src="https://dotnetfiddle.net/Widget/uEiiMr" frameborder="0"></iframe><br><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Anonymous types typically are used in the select clause of a query expression to return a subset of the properties from each object in the source sequence. For more information about queries, see LINQ in C#.<br><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Anonymous types contain one or more public read-only properties. No other kinds of class members, such as methods or events, are valid. The expression that is used to initialize a property cannot be null, an anonymous function, or a pointer type.<br><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The most common scenario is to initialize an anonymous type with properties from another type. In the following example, assume that a class exists that is named Product. Class Product includes Color and Price properties, together with other properties that you are not interested in. Variable products is a collection of Product objects. The anonymous type declaration starts with the new keyword. The declaration initializes a new type that uses only two properties from Product. Using anonymous types causes a smaller amount of data to be returned in the query.<br><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Anonymous types are class types that derive directly from object, and that cannot be cast to any type except object. The compiler provides a name for each anonymous type, although your application cannot access it. From the perspective of the common language runtime, an anonymous type is no different from any other reference type.<br><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If two or more anonymous object initializers in an assembly specify a sequence of properties that are in the same order and that have the same names and types, the compiler treats the objects as instances of the same type. They share the same compiler-generated type information.<br><br>
        </p>
</div>
    </body>
</html>